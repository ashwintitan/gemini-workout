{"ast":null,"code":"import React,{useRef,useEffect,useCallback,useState}from'react';import'./index.css';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const HorizontalScrollInput=/*#__PURE__*/React.memo(_ref=>{let{label,value,min,max,increment,onChange}=_ref;const wheelRef=useRef(null);const[itemWidth,setItemWidth]=useState(80);const[visibleItems,setVisibleItems]=useState(5);const maxIndex=Math.floor((max-min)/increment);const items=Array.from({length:maxIndex+1},(_,i)=>min+i*increment);// Dynamically calculate item width based on container\nuseEffect(()=>{const calculateWidth=()=>{if(wheelRef.current){const containerWidth=wheelRef.current.offsetWidth;setItemWidth(containerWidth/visibleItems);}};calculateWidth();window.addEventListener('resize',calculateWidth);return()=>window.removeEventListener('resize',calculateWidth);},[visibleItems]);const scrollToIndex=useCallback(function(index){let smooth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;const element=wheelRef.current;if(!element)return;const leftPadding=element.offsetWidth/2-itemWidth/2;const targetScrollLeft=index*itemWidth-leftPadding;element.scrollTo({left:targetScrollLeft,behavior:smooth?'smooth':'auto'});},[itemWidth]);useEffect(()=>{const currentIndex=Math.round((value-min)/increment);scrollToIndex(currentIndex);},[value,min,increment,scrollToIndex]);const handleScroll=useCallback(()=>{const element=wheelRef.current;if(!element)return;const leftPadding=element.offsetWidth/2-itemWidth/2;const scrollLeft=element.scrollLeft;const centeredIndex=Math.round((scrollLeft+leftPadding)/itemWidth);const newIndex=Math.max(0,Math.min(maxIndex,centeredIndex));const newValue=min+newIndex*increment;if(newValue!==value){onChange(newValue);scrollToIndex(newIndex,true);}},[value,min,increment,maxIndex,onChange,itemWidth,scrollToIndex]);return/*#__PURE__*/_jsxs(\"div\",{className:\"input-group\",children:[/*#__PURE__*/_jsx(\"label\",{className:\"input-label\",children:label}),/*#__PURE__*/_jsx(\"div\",{className:\"scroll-container\",children:/*#__PURE__*/_jsxs(\"div\",{ref:wheelRef,className:\"scroll-wheel-horizontal\",onScroll:handleScroll,children:[/*#__PURE__*/_jsx(\"div\",{className:\"scroll-padding-start\",style:{width:itemWidth*2}}),items.map((item,index)=>/*#__PURE__*/_jsx(\"div\",{className:\"scroll-item-h \".concat(item===value?'active':''),style:{width:itemWidth},children:item},index)),/*#__PURE__*/_jsx(\"div\",{className:\"scroll-padding-end\",style:{width:itemWidth*2}})]})})]});});export default HorizontalScrollInput;","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useState","jsx","_jsx","jsxs","_jsxs","HorizontalScrollInput","memo","_ref","label","value","min","max","increment","onChange","wheelRef","itemWidth","setItemWidth","visibleItems","setVisibleItems","maxIndex","Math","floor","items","Array","from","length","_","i","calculateWidth","current","containerWidth","offsetWidth","window","addEventListener","removeEventListener","scrollToIndex","index","smooth","arguments","undefined","element","leftPadding","targetScrollLeft","scrollTo","left","behavior","currentIndex","round","handleScroll","scrollLeft","centeredIndex","newIndex","newValue","className","children","ref","onScroll","style","width","map","item","concat"],"sources":["C:/Ashwin/Apps/gemini-workout/src/HorizontalScrollInput.js"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useState } from 'react';\r\nimport './index.css';\r\n\r\nconst HorizontalScrollInput = React.memo(({ label, value, min, max, increment, onChange }) => {\r\n    const wheelRef = useRef(null);\r\n    const [itemWidth, setItemWidth] = useState(80);\r\n    const [visibleItems, setVisibleItems] = useState(5);\r\n    const maxIndex = Math.floor((max - min) / increment);\r\n    const items = Array.from({ length: maxIndex + 1 }, (_, i) => min + i * increment);\r\n\r\n    // Dynamically calculate item width based on container\r\n    useEffect(() => {\r\n        const calculateWidth = () => {\r\n            if (wheelRef.current) {\r\n                const containerWidth = wheelRef.current.offsetWidth;\r\n                setItemWidth(containerWidth / visibleItems);\r\n            }\r\n        };\r\n        calculateWidth();\r\n        window.addEventListener('resize', calculateWidth);\r\n        return () => window.removeEventListener('resize', calculateWidth);\r\n    }, [visibleItems]);\r\n\r\n    const scrollToIndex = useCallback((index, smooth = false) => {\r\n        const element = wheelRef.current;\r\n        if (!element) return;\r\n        const leftPadding = (element.offsetWidth / 2) - (itemWidth / 2);\r\n        const targetScrollLeft = index * itemWidth - leftPadding;\r\n        element.scrollTo({ left: targetScrollLeft, behavior: smooth ? 'smooth' : 'auto' });\r\n    }, [itemWidth]);\r\n\r\n    useEffect(() => {\r\n        const currentIndex = Math.round((value - min) / increment);\r\n        scrollToIndex(currentIndex);\r\n    }, [value, min, increment, scrollToIndex]);\r\n\r\n    const handleScroll = useCallback(() => {\r\n        const element = wheelRef.current;\r\n        if (!element) return;\r\n\r\n        const leftPadding = (element.offsetWidth / 2) - (itemWidth / 2);\r\n        const scrollLeft = element.scrollLeft;\r\n\r\n        const centeredIndex = Math.round((scrollLeft + leftPadding) / itemWidth);\r\n        const newIndex = Math.max(0, Math.min(maxIndex, centeredIndex));\r\n        const newValue = min + newIndex * increment;\r\n\r\n        if (newValue !== value) {\r\n            onChange(newValue);\r\n            scrollToIndex(newIndex, true);\r\n        }\r\n    }, [value, min, increment, maxIndex, onChange, itemWidth, scrollToIndex]);\r\n\r\n    return (\r\n        <div className=\"input-group\">\r\n            <label className=\"input-label\">{label}</label>\r\n            <div className=\"scroll-container\">\r\n                <div ref={wheelRef} className=\"scroll-wheel-horizontal\" onScroll={handleScroll}>\r\n                    <div className=\"scroll-padding-start\" style={{ width: itemWidth * 2 }} />\r\n                    {items.map((item, index) => (\r\n                        <div\r\n                            key={index}\r\n                            className={`scroll-item-h ${item === value ? 'active' : ''}`}\r\n                            style={{ width: itemWidth }}\r\n                        >\r\n                            {item}\r\n                        </div>\r\n                    ))}\r\n                    <div className=\"scroll-padding-end\" style={{ width: itemWidth * 2 }} />\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n});\r\n\r\nexport default HorizontalScrollInput;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}